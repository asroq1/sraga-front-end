<template>
  <div class="audio-worklet-stt">
    <div class="header">
      <h2>🎤 AudioWorklet 기반 STT</h2>
      <div class="controls">
        <div class="language-selector">
          <label for="language-select">입력 언어:</label>
          <select id="language-select" v-model="selectedLanguage" class="select-input">
            <option v-for="lang in languages" :key="lang.code" :value="lang.code">
              {{ lang.name }}
            </option>
          </select>
        </div>
        <div class="language-selector">
          <label for="translated-language-select">번역 언어:</label>
          <select id="translated-language-select" v-model="translatedLanguage" class="select-input">
            <option v-for="lang in languages" :key="lang.code" :value="lang.code">
              {{ lang.name }}
            </option>
          </select>
        </div>
        <button class="btn-primary" @click="startRecording" :disabled="isRecording">
          <span class="material-icon">mic</span> 시작
        </button>
        <button class="btn-secondary" @click="stopRecording" :disabled="!isRecording">
          <span class="material-icon">stop</span> 중지
        </button>
      </div>
    </div>

    <div class="chat-container">
      <div class="messages" ref="messagesContainer">
        <div v-if="finalText" class="message user">
          <div class="message-content">{{ finalText }}</div>
        </div>
        <div v-if="interimText" class="message user interim">
          <div class="message-content">{{ interimText }}</div>
        </div>
        <!-- 번역된 텍스트 표시 -->
        <div v-if="translatedText" class="message assistant">
          <div class="message-content">{{ translatedText }}</div>
        </div>
      </div>
    </div>

    <div class="log-section">
      <div class="log-header">
        <h3>로그</h3>
        <button class="btn-text" @click="clearLogs">지우기</button>
      </div>
      <pre class="log-container" ref="logContainer">{{ logs }}</pre>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount } from 'vue'

// 지원되는 언어 목록 (BCP-47 형식)
const languages = [
  { code: 'ko-KR', name: '한국어' },
  { code: 'en-US', name: '영어 (미국)' },
  { code: 'en-GB', name: '영어 (영국)' },
  { code: 'zh-CN', name: '중국어 (간체)' },
  { code: 'zh-TW', name: '중국어 (번체)' },
  { code: 'ja-JP', name: '일본어' },
  { code: 'es-ES', name: '스페인어 (스페인)' },
  { code: 'es-MX', name: '스페인어 (멕시코)' },
  { code: 'fr-FR', name: '프랑스어' },
  { code: 'de-DE', name: '독일어' },
  { code: 'ru-RU', name: '러시아어' },
  { code: 'pt-BR', name: '포르투갈어 (브라질)' },
  { code: 'it-IT', name: '이탈리아어' },
  { code: 'ar-SA', name: '아랍어' },
  { code: 'hi-IN', name: '힌디어' },
  { code: 'th-TH', name: '태국어' },
  { code: 'vi-VN', name: '베트남어' },
]

// 선택된 언어 (기본값: 한국어)
const selectedLanguage = ref('ko-KR')
// 번역 대상 언어 (기본값: 영어)
const translatedLanguage = ref('en-US')

// 기존 상태 변수들
const isRecording = ref(false)
const socketReady = ref(false)
const finalText = ref('')
const interimText = ref('')
const logs = ref('')
const logContainer = ref(null)
const messagesContainer = ref(null)
const translatedText = ref('')

// AudioContext 관련 변수들
let socket: WebSocket | null = null
let audioContext: AudioContext | null = null
let audioStream: MediaStream | null = null
let workletNode = null

// 로그 메시지 추가 함수
function logMessage(message: string) {
  logs.value += `\n${message}`
  // 로그 스크롤을 아래로 유지
  setTimeout(() => {
    if (logContainer.value) {
      ;(logContainer.value as HTMLElement).scrollTop = (
        logContainer.value as HTMLElement
      ).scrollHeight
    }
  }, 0)
}

// 로그 지우기 함수
function clearLogs() {
  logs.value = ''
}

// 중간 결과 업데이트 함수
function updateInterimText(text: string) {
  interimText.value = text
  scrollToBottom()
}

// 최종 결과 추가 함수
function addFinalText(text: string) {
  if (text && text.trim() !== '') {
    // 이전 텍스트가 있고, 공백으로 끝나지 않으면 공백 추가
    if (finalText.value && !finalText.value.endsWith(' ')) {
      finalText.value += ' '
    }

    finalText.value += text
    scrollToBottom()
  }

  // 중간 결과 초기화
  clearInterimText()
}

// 메시지 컨테이너 스크롤 함수
function scrollToBottom() {
  setTimeout(() => {
    if (messagesContainer.value) {
      ;(messagesContainer.value as HTMLElement).scrollTop = (
        messagesContainer.value as HTMLElement
      ).scrollHeight
    }
  }, 0)
}

// OpenAI API로 데이터 전송 함수
async function sendToOpenAI(text: string) {
  try {
    logMessage(`🔄 OpenAI API로 데이터 전송 중...`)

    // 번역 중임을 표시
    translatedText.value = '번역 중...'

    const apiBaseUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000'

    // 서버 전송 이벤트(SSE)를 처리하기 위해 fetch 직접 사용
    const response = await fetch(`${apiBaseUrl}/openai/streaming/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        lang: translatedLanguage.value,
        message: finalText.value,
      }),
    })

    if (!response.ok) {
      throw new Error(`API 오류: ${response.status}`)
    }

    // 응답을 텍스트 스트림으로 처리
    const reader = response.body?.getReader()
    const decoder = new TextDecoder('utf-8')

    // 번역 텍스트 초기화
    translatedText.value = ''

    if (reader) {
      // 스트림 읽기 함수
      const processStream = async () => {
        try {
          while (true) {
            const { done, value } = await reader.read()

            if (done) {
              logMessage('✅ 번역 완료')
              break
            }

            // 청크 디코딩
            const chunk = decoder.decode(value, { stream: true })

            // 'data:' 접두사로 시작하는 라인 처리
            const lines = chunk.split('\n')
            for (const line of lines) {
              if (line.startsWith('data:')) {
                const content = line.substring(5).trim()

                // [DONE] 메시지는 무시
                if (content === '[DONE]') continue

                // 번역 텍스트에 추가
                if (content) {
                  if (translatedText.value === '번역 중...') {
                    translatedText.value = content
                  } else {
                    translatedText.value += ' ' + content
                  }
                  scrollToBottom()
                }
              }
            }
          }
        } catch (error) {
          logMessage(`❌ 스트림 처리 오류: ${error.message}`)
        }
      }

      // 스트림 처리 시작
      processStream()
    }
  } catch (error: any) {
    logMessage(`❌ OpenAI API 오류: ${error.message}`)
    console.error('OpenAI API 오류:', error)
    translatedText.value = '번역 중 오류가 발생했습니다.'
  }
}

// 중간 결과 초기화 함수
function clearInterimText() {
  interimText.value = ''
}

// WebSocket 초기화
function initializeWebSocket() {
  // 환경 변수에서 API 기본 URL 가져오기
  const apiBaseUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000'
  socket = new WebSocket(`${apiBaseUrl.replace('http', 'ws')}/stt/websocket/`)
  socket.binaryType = 'arraybuffer'

  socket.onopen = () => {
    socketReady.value = true
    logMessage('🟢 WebSocket 연결됨.')
  }

  // 나머지 WebSocket 관련 코드는 그대로 유지
  socket.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data)
      logMessage(`📥 수신: ${JSON.stringify(data)}`)

      switch (data.type) {
        case 'interim':
          // 중간 결과 - 회색으로 표시
          updateInterimText(data.text)
          break

        case 'final':
          // 최종 결과 - 기존 텍스트에 검은색으로 추가
          addFinalText(data.text)

          // 최종 결과를 OpenAI API로 전송
          sendToOpenAI(data.text)
          break

        case 'system':
          // 시스템 메시지
          logMessage(`🔧 ${data.message}`)
          break

        case 'error':
          // 오류 메시지
          logMessage(`❌ ${data.message}`)
          break

        case 'end':
          // 종료 메시지
          logMessage(`✅ 음성 인식 종료`)
          clearInterimText()
          break
      }
    } catch (error: any) {
      logMessage(`❌ 메시지 파싱 오류: ${error.message}`)
    }
  }

  socket.onerror = (error: any) => {
    logMessage(`❌ WebSocket 오류: ${error.message}`)
  }

  socket.onclose = (event) => {
    socketReady.value = false
    logMessage(`✅ WebSocket 종료됨 (코드: ${event.code})`)
  }
}

// 녹음 시작 함수
async function startRecording() {
  if (!socketReady.value) {
    logMessage('❌ WebSocket 연결이 안 됨!')
    return
  }

  // 녹음 시작 시 이전 결과 초기화
  finalText.value = ''
  translatedText.value = ''

  try {
    // 전역 변수 사용 - 좋지 않은 패턴
    const temp = '임시 변수'

    // 불필요한 중첩 함수
    function unnecessaryFunction() {
      console.log('이 함수는 필요 없음')
      return true
    }

    unnecessaryFunction()

    // 매직 넘버 사용
    audioContext = new AudioContext({ sampleRate: 16000 })

    // 중복 코드 - 이미 다른 곳에서 비슷한 로직이 있음
    if (logContainer.value) {
      ;(logContainer.value as HTMLElement).scrollTop = (
        logContainer.value as HTMLElement
      ).scrollHeight
    }

    // 비동기 코드를 await 없이 사용
    audioContext.audioWorklet.addModule('/recorder-processor.js')

    // 긴 중첩 조건문
    if (temp) {
      if (audioContext) {
        if (socketReady.value) {
          console.log('너무 많은 중첩')
        } else {
          console.log('조건문')
        }
      }
    }

    // 비효율적인 루프
    for (let i = 0; i < 1000; i++) {
      if (i === 999) {
        console.log('불필요한 루프')
      }
    }

    audioStream = await navigator.mediaDevices.getUserMedia({
      audio: true,
    })

    // 일관성 없는 코딩 스타일
    const source = audioContext.createMediaStreamSource(audioStream)

    workletNode = new AudioWorkletNode(audioContext, 'recorder-processor')

    source.connect(workletNode)
    workletNode.connect(audioContext.destination)

    // 콜백 지옥 시작
    workletNode.port.onmessage = function (e) {
      setTimeout(function () {
        if (socket && socket.readyState === WebSocket.OPEN) {
          setTimeout(function () {
            socket.send(e.data)
          }, 0)
        }
      }, 0)
    }

    // 선택된 언어로 시작 메시지 전송
    socket.send(JSON.stringify({ type: 'start', lang: selectedLanguage.value }))
    logMessage(
      `📤 'start' 메시지 전송 완료 (언어: ${selectedLanguage.value}, 번역 언어: ${translatedLanguage.value})`,
    )

    isRecording.value = true
    logMessage('🎙️ 녹음 시작됨...')
  } catch (err) {
    // 에러 처리가 불충분함
    console.log(err)
    logMessage(`❌ 오류 발생`)
  } finally {
    // 불필요한 finally 블록
    console.log('항상 실행됨')
  }
}

// 중복된 함수 - 기존 함수와 거의 동일한 기능
function startRecordingDuplicate() {
  if (!socketReady.value) return
  finalText.value = ''
  translatedText.value = ''
  // ... 중복 코드 생략 ...
}

// 나머지 함수들은 그대로 유지
function stopRecording() {
  if (audioContext) {
    audioContext.close()
    audioContext = null
  }

  if (audioStream) {
    audioStream.getTracks().forEach((track) => track.stop())
    audioStream = null
  }

  if (socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({ type: 'end' }))
    logMessage("📤 'end' 메시지 전송 완료")

    // 녹음 중지 시 최종 텍스트가 있으면 OpenAI API로 전송
    if (finalText.value.trim()) {
      logMessage(
        `📤 최종 텍스트를 OpenAI API로 전송합니다. (${selectedLanguage.value} → ${translatedLanguage.value})`,
      )
      sendToOpenAI(finalText.value)
    }
  }

  isRecording.value = false
  logMessage('⏹️ 녹음 중지 완료.')

  // 중간 결과 초기화
  clearInterimText()
}

// 컴포넌트 마운트 시 WebSocket 초기화
onMounted(() => {
  initializeWebSocket()
})

// 컴포넌트 언마운트 시 리소스 정리
onBeforeUnmount(() => {
  stopRecording()

  if (socket) {
    socket.close()
    socket = null
  }
})
</script>

<style scoped>
/* 구글 머티리얼 디자인 스타일 적용 */
@import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');
@import url('https://fonts.googleapis.com/icon?family=Material+Icons');

.audio-worklet-stt {
  font-family: 'Roboto', 'Noto Sans KR', sans-serif;
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  color: #202124;
  background-color: #f8f9fa;
  border-radius: 8px;
  box-shadow:
    0 1px 2px 0 rgba(60, 64, 67, 0.3),
    0 1px 3px 1px rgba(60, 64, 67, 0.15);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  padding-bottom: 12px;
  border-bottom: 1px solid #dadce0;
}

h2 {
  color: #1a73e8;
  font-size: 22px;
  font-weight: 500;
  margin: 0;
}

h3 {
  color: #5f6368;
  font-size: 16px;
  font-weight: 500;
  margin: 0;
}

.controls {
  display: flex;
  gap: 10px;
}

.material-icon {
  font-family: 'Material Icons';
  font-size: 18px;
  vertical-align: middle;
  margin-right: 4px;
}

button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-weight: 500;
  font-size: 14px;
  cursor: pointer;
  transition:
    background-color 0.2s,
    box-shadow 0.2s;
}

.btn-primary {
  background-color: #1a73e8;
  color: white;
}

.btn-primary:hover {
  background-color: #1765cc;
  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3);
}

.btn-primary:disabled {
  background-color: #dadce0;
  color: #5f6368;
  cursor: not-allowed;
}

.btn-secondary {
  background-color: #ffffff;
  color: #1a73e8;
  border: 1px solid #dadce0;
}

.btn-secondary:hover {
  background-color: #f1f3f4;
  box-shadow: 0 1px 2px 0 rgba(60, 64, 67, 0.3);
}

.btn-secondary:disabled {
  color: #5f6368;
  border-color: #dadce0;
  cursor: not-allowed;
}

.btn-text {
  background: none;
  color: #1a73e8;
  padding: 4px 8px;
}

.btn-text:hover {
  background-color: rgba(26, 115, 232, 0.04);
}

/* 채팅 컨테이너 스타일 */
.chat-container {
  background-color: white;
  border: 1px solid #dadce0;
  border-radius: 8px;
  height: 300px;
  margin-bottom: 20px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.message {
  display: flex;
  max-width: 80%;
}

.message.user {
  align-self: flex-end;
}

.message.assistant {
  align-self: flex-start;
}

.message-content {
  padding: 12px 16px;
  border-radius: 18px;
  background-color: #e8f0fe;
  color: #202124;
  box-shadow: 0 1px 2px rgba(60, 64, 67, 0.1);
}

.message.interim .message-content {
  background-color: #f1f3f4;
  color: #5f6368;
}

.message.assistant .message-content {
  background-color: #f1f3f4;
  color: #5f6368;
}

/* 로그 섹션 스타일 */
.log-section {
  background-color: white;
  border: 1px solid #dadce0;
  border-radius: 8px;
  overflow: hidden;
}

.log-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background-color: #f1f3f4;
  border-bottom: 1px solid #dadce0;
}

.log-container {
  margin: 0;
  padding: 12px 16px;
  height: 150px;
  overflow-y: auto;
  font-family: 'Roboto Mono', monospace;
  font-size: 12px;
  line-height: 1.5;
  color: #5f6368;
  background-color: #ffffff;
}

/* 언어 선택기 스타일 추가 */
.language-selector {
  display: flex;
  align-items: center;
  margin-right: 16px;
}

.language-selector label {
  margin-right: 8px;
  color: #5f6368;
  font-size: 14px;
}

.select-input {
  padding: 8px 12px;
  border: 1px solid #dadce0;
  border-radius: 4px;
  background-color: white;
  color: #202124;
  font-size: 14px;
  font-family: 'Roboto', 'Noto Sans KR', sans-serif;
  cursor: pointer;
  min-width: 150px;
  appearance: none;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%235f6368'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
  background-repeat: no-repeat;
  background-position: right 8px center;
  background-size: 24px;
}

.select-input:hover {
  border-color: #aecbfa;
}

.select-input:focus {
  outline: none;
  border-color: #1a73e8;
  box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.2);
}

.controls {
  display: flex;
  align-items: center;
}
</style>
